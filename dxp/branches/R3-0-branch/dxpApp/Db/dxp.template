# dxp.template
# Database for XIA DXP detectors (DXP-2X, Saturn, and xMAP).
# This database does not contain the records that are specific
# to the xMAP mapping mode, those are in dxp_mapping.template

# Changes from original
#  - Energy units changed from eV to keV
#  - Set all output links to PINI=YES.  If 1 then save/restore is used, if 0 then ini file is used
#  - Set a reasonable default value for all outputs
#  - asynUInt32Digital interface changed to asynInt32
#  - No fanouts in database
#  - Each link is of the form "@asyn($(PORT),$(ADDR),$(TIMEOUT))"
#  - No forward links, all readbacks are I/O Intr scanned
#  - Changed xmap_trace to NDDxpTraceMode and NDDxpTraceTime
#  - Changed trace time units from ns to us
#  - Deleted APPLY record, driver should do apply automatically
#  - Deletect mca_bin_width, replaced with NDDxpMaxEnergy
#  - No record for number_mca_channels, that is set by MCA_NUM_CHANNELS
#  - Added preamp_gain, detector_polarity, reset_delay, gap_time, trigger_peaking_time, 
#    trigger_gap_time, baseline_average 

record(ao, "$(P)$(R)PeakingTime") {
  field(PINI, $(PINI))
  field(VAL,  "1.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpPeakingTime")
  field(PREC, "3")
  field(EGU, "us")
}

record(ai, "$(P)$(R)PeakingTime_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpPeakingTime")
  field(PREC, "3")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

#record(ao, "$(P)$(R)DynamicRange") {
#  field(PINI, $(PINI))
#  field(VAL,  "40.0")
#  field(DTYP, "asynFloat64")
#  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpDynamicRange")
#  field(PREC, "3")
#  field(EGU, "keV")
#}

record(ai, "$(P)$(R)DynamicRange_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpDynamicRange")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)TriggerThreshold") {
  field(PINI, $(PINI))
  field(VAL,  "0.15")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTriggerThreshold")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)TriggerThreshold_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTriggerThreshold")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)BaselineThreshold") {
  field(PINI, $(PINI))
  field(VAL,  "2.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpBaselineThreshold")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)BaselineThreshold_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpBaselineThreshold")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)BaselineCutPercent") {
  field(PINI, $(PINI))
  field(VAL,  "5.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpBaselineCut")
  field(PREC, "3")
  field(EGU, "%")
}

record(ai, "$(P)$(R)BaselineCutPercent_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpBaselineCut")
  field(PREC, "3")
  field(EGU, "%")
  field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)BaselineCutEnable") {
   field(PINI, $(PINI))
   field(VAL,  "1")
   field(DTYP, "asynInt32")
   field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpEnableBaselineCut")
   field(ZNAM, "No")
   field(ONAM, "Yes")
}

record(bi, "$(P)$(R)BaselineCutEnable_RBV") {
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpEnableBaselineCut")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(mbbo, "$(P)$(R)BaselineFilterLength") {
  field(DESC, "baseline filter len")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpBaselineAverage")
  field(ZRST, "8")
  field(ZRVL, "8")
  field(ONVL, "16")
  field(ONST, "16")
  field(TWVL, "32")
  field(TWST, "32")
  field(THVL, "64")
  field(THST, "64")
  field(FRVL, "128")
  field(FRST, "128")
  field(FVVL, "256")
  field(FVST, "256")
  field(SXVL, "512")
  field(SXST, "512")
  field(SVVL, "1024")
  field(SVST, "1024")
  field(EIVL, "2048")
  field(EIST, "2048")
  field(IVOA, "Don't drive outputs")
}

record(longin, "$(P)$(R)BaselineFilterLength_RBV") {
#  field(PINI, "RUNNING")
  field(DESC, "baseline filter len")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpBaselineAverage")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)EnergyThreshold") {
  field(PINI, $(PINI))
  field(VAL,  "0.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpEnergyThreshold")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)EnergyThreshold_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpEnergyThreshold")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

# Note: I don't think calibration energy is used if dynamic range is used.
# One either uses calibration_energy and adc_percent_rule or dynamic_range
# In any event we force ECAL=EMAX/2. in driver, so only read it back
#record(ao, "$(P)$(R)CalibrationEnergy") {
#  field(PINI, $(PINI))
#  field(VAL,  "10.0")
#  field(DTYP, "asynFloat64")
#  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpCalibrationEnergy")
#  field(PREC, "3")
#  field(EGU, "keV")
#}

record(ai, "$(P)$(R)CalibrationEnergy_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpCalibrationEnergy")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)ADCPercentRule") {
  field(PINI, $(PINI))
  field(VAL,  "5.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpADCPercentRule")
  field(PREC, "1")
  field(EGU, "%")
}

record(ai, "$(P)$(R)ADCPercentRule_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpADCPercentRule")
  field(PREC, "1")
  field(EGU, "%")
  field(SCAN, "I/O Intr")
}

# mca_bin_width is not a user-friendly concept.  Use EMAX instead
# for setting, but allow reading back
#record(ao, "$(P)$(R)MCABinWidth") {
#  field(PINI, $(PINI))
#  field(VAL,  "10.0")
#  field(DTYP, "asynFloat64")
#  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpMCABinWidth")
#  field(PREC, "3")
#  field(EGU, "eV/bin")
#}

record(ai, "$(P)$(R)MCABinWidth_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpMcaBinWidth")
  field(PREC, "3")
  field(EGU, "eV/bin")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)MaxEnergy") {
  field(PINI, $(PINI))
  field(VAL,  "20.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpMaxEnergy")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)MaxEnergy_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpMaxEnergy")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)PreampGain") {
  field(PINI, $(PINI))
  field(VAL,  "2.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpPreampGain")
  field(PREC, "4")
  field(EGU, "mV/keV")
}

record(ai, "$(P)$(R)PreampGain_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpPreampGain")
  field(PREC, "4")
  field(EGU, "mV/keV")
  field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)DetectorPolarity") {
   field(PINI, $(PINI))
   field(VAL,  "1")
   field(DTYP, "asynInt32")
   field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpDetectorPolarity")
   field(ZNAM, "Negative")
   field(ONAM, "Positive")
}

record(bi, "$(P)$(R)DetectorPolarity_RBV") {
 #  field(PINI, "RUNNING")
   field(DTYP, "asynInt32")
   field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpDetectorPolarity")
   field(ZNAM, "Negative")
   field(ONAM, "Positive")
   field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)ResetDelay") {
  field(PINI, $(PINI))
  field(VAL,  "2.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpResetDelay")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)ResetDelay_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpResetDelay")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)GapTime") {
  field(PINI, $(PINI))
  field(VAL,  "0.2")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpGapTime")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)GapTime_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpGapTime")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)TriggerPeakingTime") {
  field(PINI, $(PINI))
  field(VAL,  "0.15")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTriggerPeakingTime")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)TriggerPeakingTime_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTriggerPeakingTime")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)TriggerGapTime") {
  field(PINI, $(PINI))
  field(VAL,  "0.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTriggerGapTime")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)TriggerGapTime_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTriggerGapTime")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)MaxWidth") {
  field(PINI, $(PINI))
  field(VAL,  "4.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpMaxWidth")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)MaxWidth_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpMaxWidth")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)ReadDXPParams") {
  field(PINI, "NO")
  field(DESC, "get status info")
  field(SCAN, "Passive")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpReadDXPParams")
  field(ZNAM, "Done")
  field(ONAM, "Read")
}

record(mbbo, "$(P)$(R)TraceMode") {
  field(PINI, $(PINI))
  field(DESC, "set trace mode")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTraceMode")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(TWVL, "2")
  field(THVL, "3")
  field(FRVL, "4")
  field(FVVL, "5")
  field(SXVL, "6")
  field(ZRST, "ADC")
  field(ONST, "baseline hist")
  field(TWST, "trigger filter")
  field(THST, "baseline filter")
  field(FRST, "energy filter")
  field(FVST, "baseline smpls.")
  field(SXST, "energy smpls.")
  field(IVOA, "Don't drive outputs")
}

record(mbbi, "$(P)$(R)TraceMode_RBV") {
#  field(PINI, "RUNNING")
  field(DESC, "set trace mode")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTraceMode")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(TWVL, "2")
  field(THVL, "3")
  field(FRVL, "4")
  field(FVVL, "5")
  field(SXVL, "6")
  field(ZRST, "ADC")
  field(ONST, "baseline hist")
  field(TWST, "trigger filter")
  field(THST, "baseline filter")
  field(FRST, "energy filter")
  field(FVST, "baseline smpls.")
  field(SXST, "energy smpls.")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)TraceTime") {
  field(PINI, $(PINI))
  field(VAL, "1.0")
  field(DESC, "set trace sample time")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTraceTime")
  field(PREC, "2")
  field(EGU, "us")
  field(HOPR, "13107.00")
  field(LOPR, "0.020")
}

record(ai, "$(P)$(R)TraceTime_RBV") {
#  field(PINI, "RUNNING")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTraceTime")
  field(PREC, "2")
  field(EGU, "us")
  field(HOPR, "13107.00")
  field(LOPR, "0.020")
  field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(R)TraceData") {
  field(DESC, "Get trace data")
  field(DTYP, "asynInt32ArrayIn")
  field(PREC, "0")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTrace")
  field(NELM, "4096")
  field(FTVL, "LONG")
}

record(waveform, "$(P)$(R)BaselineHistogram") {
  field(DESC, "Baseline Histogram")
  field(DTYP, "asynInt32ArrayIn")
  field(PREC, "0")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpBaselineHistogram")
  field(NELM, "1024")
  field(FTVL, "LONG")
}

# This is really redundant with the MCA_ELAPSED_REAL parameter
record(ai, "$(P)$(R)ElapsedRealTime") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpElapsedRealTime")
  field(DESC, "number of triggers")
  field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)ElapsedTriggerLiveTime") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpElapsedTriggerLiveTime")
  field(DESC, "trigger live time")
  field(SCAN, "I/O Intr")
}

# This is really redundant with the MCA_ELAPSED_LIVE parameter
record(ai, "$(P)$(R)ElapsedLiveTime") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpElapsedLiveTime")
  field(DESC, "Energy live time")
  field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)Triggers") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpTriggers")
  field(DESC, "number of triggers")
  field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)Events") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpEvents")
  field(DESC, "number of events")
  field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)InputCountRate") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpInputCountRate")
  field(DESC, "incident count rate")
  field(PREC, "1")
  field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)OutputCountRate") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpOutputCountRate")
  field(DESC, "output count rate")
  field(PREC, "1")
  field(SCAN, "I/O Intr")
}

# The convention is that the MCA presets: preset live takes precedence over real, both 0=None
# MCA has preset counts, this just allows choice of count for events or triggers
record(mbbo, "$(P)$(R)PresetCountMode") {
  field(PINI, $(PINI))
  field(DESC, "set preset type for preset counts")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpPresetCountMode")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(ZRST, "events")
  field(ONST, "triggers")
}

record(mbbi, "$(P)$(R)PresetCountMode_RBV") {
  field(DESC, "set preset type for preset counts")
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DxpPresetCountMode")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(ZRST, "events")
  field(ONST, "triggers")
  field(SCAN, "I/O Intr")
}

