# dxp.template
# Database for XIA DXP detectors (DXP-2X, Saturn, and xMAP).
# This database does not contain the records that are specific
# to the xMAP mapping mode, those are in dxp_mapping.template

# Changes from original
#  - Energy units changed from eV to keV
#  - Set all output links to PINI=YES.  If 1 then save/restore is used, if 0 then ini file is used
#  - Set a reasonable default value for all outputs
#  - asynUInt32Digital interface changed to asynInt32
#  - No fanouts in database
#  - Each link is of the form "@asyn($(PORT),$(ADDR),$(TIMEOUT))"
#  - No forward links, all readbacks are I/O Intr scanned
#  - Changed xmap_trace to NDDxpTraceMode and NDDxpTraceTime
#  - Changed trace time units from ns to us
#  - Deleted APPLY record, driver should do apply automatically
#  - Deletect mca_bin_width, replaced with NDDxpMaxEnergy
#  - No record for number_mca_channels, that is set by MCA_NUM_CHANNELS
#  - Added preamp_gain, detector_polarity, reset_delay, gap_time, trigger_peaking_time, 
#    trigger_gap_time, baseline_average 

record(ao, "$(P)$(R)PKTIM") {
  field(PINI, "YES")
  field(VAL,  "1.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))peaking_time")
  field(PREC, "3")
  field(EGU, "us")
}

record(ai, "$(P)$(R)PKTIM_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))peaking_time")
  field(PREC, "3")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DYNRANGE") {
  field(PINI, "YES")
  field(VAL,  "40.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))dynamic_range")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)DYNRANGE_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))dynamic_range")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)FAST_TRIG") {
  field(PINI, "YES")
  field(VAL,  "0.15")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))trigger_threshold")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)FAST_TRIG_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))trigger_threshold")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)BASE_THRESH") {
  field(PINI, "YES")
  field(VAL,  "2.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))baseline_threshold")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)BASE_THRESH_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))baseline_threshold")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)BASE_CUT_PCT") {
  field(PINI, "YES")
  field(VAL,  "5.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))baseline_cut")
  field(PREC, "3")
  field(EGU, "%")
}

record(ai, "$(P)$(R)BASE_CUT_PCT_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))baseline_cut")
  field(PREC, "3")
  field(EGU, "%")
  field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)BASE_CUT_ENBL") {
   field(PINI, "YES")
   field(VAL,  "1")
   field(DTYP, "asynInt32")
   field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))enable_baseline_cut")
   field(ZNAM, "No")
   field(ONAM, "Yes")
}

record(bi, "$(P)$(R)BASE_CUT_ENBL_RBV") {
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))enable_baseline_cut")
   field(ZNAM, "No")
   field(ONAM, "Yes")
   field(SCAN, "I/O Intr")
}

record(mbbo, "$(P)$(R)BASE_LEN") {
  field(DESC, "baseline filter len")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))baseline_average")
  field(ZRST, "8")
  field(ZRVL, "8")
  field(ONVL, "16")
  field(ONST, "16")
  field(TWVL, "32")
  field(TWST, "32")
  field(THVL, "64")
  field(THST, "64")
  field(FRVL, "128")
  field(FRST, "128")
  field(FVVL, "256")
  field(FVST, "256")
  field(SXVL, "512")
  field(SXST, "512")
  field(SVVL, "1024")
  field(SVST, "1024")
  field(EIVL, "2048")
  field(EIST, "2048")
  field(IVOA, "Don't drive outputs")
}

record(longin, "$(P)$(R)BASE_LEN_RBV") {
  field(PINI, "YES")
  field(DESC, "baseline filter len")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))baseline_average")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)ENERGY_THRESH") {
  field(PINI, "YES")
  field(VAL,  "0.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))energy_threshold")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)ENERGY_THRESH_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))energy_threshold")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

# Note: I don't think calibration energy is used if dynamic range is used.
# One either uses calibration_energy and adc_percent_rule or dynamic_range
# In any event we force ECAL=EMAX/2. in driver, so only read it back
#record(ao, "$(P)$(R)ECAL") {
#  field(PINI, "YES")
#  field(VAL,  "10.0")
#  field(DTYP, "asynFloat64")
#  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))calibration_energy")
#  field(PREC, "3")
#  field(EGU, "keV")
#}

record(ai, "$(P)$(R)ECAL_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))calibration_energy")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)ADC_RULE") {
  field(PINI, "YES")
  field(VAL,  "5.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))adc_percent_rule")
  field(PREC, "1")
  field(EGU, "%")
}

record(ai, "$(P)$(R)ADC_RULE_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))adc_percent_rule")
  field(PREC, "1")
  field(EGU, "%")
  field(SCAN, "I/O Intr")
}

# mca_bin_width is not a user-friendly concept.  Use EMAX instead
# for setting, but allow reading back
#record(ao, "$(P)$(R)BIN_WIDTH") {
#  field(PINI, "YES")
#  field(VAL,  "10.0")
#  field(DTYP, "asynFloat64")
#  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))mca_bin_width")
#  field(PREC, "3")
#  field(EGU, "eV/bin")
#}

record(ai, "$(P)$(R)BIN_WIDTH_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))mca_bin_width")
  field(PREC, "3")
  field(EGU, "eV/bin")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)EMAX") {
  field(PINI, "YES")
  field(VAL,  "20.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpMaxEnergy")
  field(PREC, "3")
  field(EGU, "keV")
}

record(ai, "$(P)$(R)EMAX_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpMaxEnergy")
  field(PREC, "3")
  field(EGU, "keV")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)PGAIN") {
  field(PINI, "YES")
  field(VAL,  "2.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))preamp_gain")
  field(PREC, "4")
  field(EGU, "mV/keV")
}

record(ai, "$(P)$(R)PGAIN_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))preamp_gain")
  field(PREC, "4")
  field(EGU, "mV/keV")
  field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)POLARITY") {
   field(PINI, "YES")
   field(VAL,  "1")
   field(DTYP, "asynInt32")
   field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))detector_polarity")
   field(ZNAM, "Negative")
   field(ONAM, "Positive")
}

record(bi, "$(P)$(R)POLARITY_RBV") {
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))detector_polarity")
   field(ZNAM, "Negative")
   field(ONAM, "Positive")
   field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)RESET_DELAY") {
  field(PINI, "YES")
  field(VAL,  "2.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))reset_delay")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)RESET_DELAY_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))reset_delay")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)GAPTIM") {
  field(PINI, "YES")
  field(VAL,  "0.2")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))gap_time")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)GAPTIM_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))gap_time")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)TRIG_PKTIM") {
  field(PINI, "YES")
  field(VAL,  "0.15")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))trigger_peaking_time")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)TRIG_PKTIM_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))trigger_peaking_time")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)TRIG_GAPTIM") {
  field(PINI, "YES")
  field(VAL,  "0.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))trigger_gap_time")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)TRIG_GAPTIM_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))trigger_gap_time")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)MAX_WIDTH") {
  field(PINI, "YES")
  field(VAL,  "4.0")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))maxwidth")
  field(PREC, "2")
  field(EGU, "us")
}

record(ai, "$(P)$(R)MAX_WIDTH_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))maxwidth")
  field(PREC, "2")
  field(EGU, "us")
  field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)READ_STATUS") {
  field(PINI, "NO")
  field(DESC, "get status info")
  field(SCAN, "Passive")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpReadDXPParams")
  field(ZNAM, "Done")
  field(ONAM, "Read")
}

record(mbbo, "$(P)$(R)TRACE_MODE") {
  field(PINI, "YES")
  field(DESC, "set trace mode")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpTraceMode")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(TWVL, "2")
  field(THVL, "3")
  field(FRVL, "4")
  field(FVVL, "5")
  field(SXVL, "6")
  field(ZRST, "ADC")
  field(ONST, "baseline hist")
  field(TWST, "trigger filter")
  field(THST, "baseline filter")
  field(FRST, "energy filter")
  field(FVST, "baseline smpls.")
  field(SXST, "energy smpls.")
  field(IVOA, "Don't drive outputs")
}

record(mbbi, "$(P)$(R)TRACEMODE_RBV") {
  field(PINI, "YES")
  field(DESC, "set trace mode")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpTraceMode")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(TWVL, "2")
  field(THVL, "3")
  field(FRVL, "4")
  field(FVVL, "5")
  field(SXVL, "6")
  field(ZRST, "ADC")
  field(ONST, "baseline hist")
  field(TWST, "trigger filter")
  field(THST, "baseline filter")
  field(FRST, "energy filter")
  field(FVST, "baseline smpls.")
  field(SXST, "energy smpls.")
  field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)TRACE_TIME") {
  field(PINI, "YES")
  field(VAL, "1.0")
  field(DESC, "set trace sample time")
  field(DTYP, "asynFloat64")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpTraceTime")
  field(PREC, "2")
  field(EGU, "us")
  field(HOPR, "13107.00")
  field(LOPR, "0.020")
}

record(ai, "$(P)$(R)TRACE_TIME_RBV") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpTraceTime")
  field(PREC, "2")
  field(EGU, "us")
  field(HOPR, "13107.00")
  field(LOPR, "0.020")
  field(SCAN, "I/O Intr")
}

record(waveform, "$(P)$(R)TRACE_DATA") {
  field(DESC, "Get trace data")
  field(DTYP, "asynInt32ArrayIn")
  field(PREC, "0")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpTrace")
  field(NELM, "4096")
  field(FTVL, "LONG")
}

record(waveform, "$(P)$(R)BaselineHistogram") {
  field(DESC, "Baseline Histogram")
  field(DTYP, "asynInt32ArrayIn")
  field(PREC, "0")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpBaselineHistogram")
  field(NELM, "1024")
  field(FTVL, "LONG")
}

# This is really redundant with the MCA_ELAPSED_REAL parameter
record(ai, "$(P)$(R)REALTIME") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxp_STAT_REALTIME")
  field(DESC, "number of triggers")
  field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)TRIG_LIVETIME") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxp_STAT_TRIGLTIME")
  field(DESC, "trigger live time")
  field(SCAN, "I/O Intr")
}

# This is really redundant with the MCA_ELAPSED_LIVE parameter
record(ai, "$(P)$(R)ENERGY_LIVETIME") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxp_STAT_ELTIME")
  field(DESC, "Energy live time")
  field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)TRIGGERS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxp_STAT_TRIGGERS")
  field(DESC, "number of triggers")
  field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)EVENTS") {
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxp_STAT_EVENTS")
  field(DESC, "number of events")
  field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)ICR") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxp_STAT_INCNTRATE")
  field(DESC, "incident count rate")
  field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)OCR") {
  field(DTYP, "asynFloat64")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxp_STAT_OUTCNTRATE")
  field(DESC, "output count rate")
  field(SCAN, "I/O Intr")
}

# The convention is that the MCA presets: preset live takes precedence over real, both 0=None
# MCA has preset counts, this just allows choice of count for events or triggers
record(mbbo, "$(P)$(R)PRESET_COUNT_MODE") {
  field(PINI, "YES")
  field(DESC, "set preset type for preset counts")
  field(DTYP, "asynInt32")
  field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpPresetCountMode")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(ZRST, "events")
  field(ONST, "triggers")
}

record(mbbi, "$(P)$(R)PRESET_COUNT_MODE_RBV") {
  field(DESC, "set preset type for preset counts")
  field(DTYP, "asynInt32")
  field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDDxpPresetCountMode")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(ZRST, "events")
  field(ONST, "triggers")
  field(SCAN, "I/O Intr")
}

